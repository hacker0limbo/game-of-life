{"version":3,"sources":["App.tsx","constants.ts","index.tsx"],"names":["gridStyles","display","gridTemplateColumns","operations","countNeighbours","grid","x","y","reduce","acc","coord","i","j","col","App","useState","Array","map","row","fill","setGrid","speed","setSpeed","running","setRunning","runningRef","useRef","current","speedRef","runSimulation","useCallback","prevGrid","produce","draftGrid","neighbours","setTimeout","onClick","rows","push","from","Math","random","type","min","max","value","onChange","e","Number","target","style","key","className","backgroundColor","undefined","newGrid","handleColClick","ReactDOM","render","document","getElementById"],"mappings":"gNAIMA,EAAa,CACjBC,QAAS,OACTC,oBAAoB,UAAD,OCLE,GDKF,YAIfC,EAAa,CACjB,CAAC,EAAG,GACJ,CAAC,GAAI,GACL,CAAC,GAAI,GACL,EAAE,EAAG,GACL,CAAC,EAAG,GACJ,EAAE,GAAI,GACN,CAAC,EAAG,GACJ,EAAE,EAAG,IAGDC,EAAkB,SAACC,EAAkBC,EAAWC,GAEpD,OAAOJ,EAAWK,QAAO,SAACC,EAAKC,GAAW,IAAD,cACxBA,EADwB,GAChCC,EADgC,KAC7BC,EAD6B,KAGjCC,GAAON,EAAIK,ECzBE,OD2BnB,OADAH,GAAOJ,GAFMC,EAAIK,ECzBE,QD2BFE,KAEhB,IA+GUC,EA5GO,WAAO,IAAD,EACFC,oBAAS,WAC/B,OAAO,YAAIC,MClCQ,KDkCQC,KAAI,SAAAC,GAAG,OAAI,IAAIF,MCjCvB,IDiCsCG,KAAK,SAFtC,mBACnBd,EADmB,KACbe,EADa,OAIAL,mBAAS,KAJT,mBAInBM,EAJmB,KAIZC,EAJY,OAKIP,oBAAS,GALb,mBAKnBQ,EALmB,KAKVC,EALU,KAOpBC,EAAaC,iBAAOH,GAC1BE,EAAWE,QAAUJ,EACrB,IAAMK,EAAWF,iBAAOL,GACxBO,EAASD,QAAUN,EAEnB,IAAMQ,EAAgBC,uBAAY,WAK3BL,EAAWE,UAQhBP,GAAQ,SAAAW,GACN,OAAOC,YAAQD,GAAU,SAAAE,GACvB,IAAK,IAAI3B,EAAI,EAAGA,EC3DD,GD2DcA,IAC3B,IAAK,IAAIC,EAAI,EAAGA,EC3DH,GD2DgBA,IAAK,CAChC,IAAM2B,EAAa9B,EAAgB2B,EAAUzB,EAAGC,GAE5C2B,EAAa,GAAKA,EAAa,EACjCD,EAAU3B,GAAGC,GAAK,EACU,IAAnBwB,EAASzB,GAAGC,IAA2B,IAAf2B,IACjCD,EAAU3B,GAAGC,GAAK,UAO5B4B,WAAWN,EAAeD,EAASD,YAClC,IAiCH,OACE,oCACE,6BACE,4BAAQS,QAfQ,WACpBZ,GAAYD,GACPA,IACHE,EAAWE,SAAU,EACrBE,OAYKN,EAAU,OAAS,SAEtB,4BAAQa,QArCU,WACtBhB,EAAQ,YAAIJ,MC7EO,KD6ESC,KAAI,SAAAC,GAAG,OAAI,IAAIF,MC5ExB,ID4EuCG,KAAK,SAoC3D,SACA,4BAAQiB,QAlCW,WAEvB,IADA,IAAMC,EAAO,GACJ1B,EAAI,EAAGA,EClFG,GDkFUA,IAC3B0B,EAAKC,KAAKtB,MAAMuB,KAAKvB,MClFJ,KDkFoB,kBAAMwB,KAAKC,SAAW,GAAM,EAAI,MAEvErB,EAAQiB,KA6BJ,WAEF,6BACE,iDACA,2BACEK,KAAK,QACLC,IAAI,KACJC,IAAI,OACJC,MAAOxB,EACPyB,SApBmB,SAACC,GAC1BzB,EAAS0B,OAAOD,EAAEE,OAAOJ,YAsBvB,yBAAKK,MAAOlD,GACTK,EAAKY,KAAI,SAACC,EAAKP,GAAN,OAAYO,EAAID,KAAI,SAACJ,EAAKD,GAAN,OAC5B,yBACEuC,IAAG,UAAKxC,EAAL,YAAUC,GACbwC,UAAU,MACVF,MAAO,CAACG,gBAAiBhD,EAAKM,GAAGC,GAAK,YAAS0C,GAC/ClB,QAAS,kBA5CI,SAACzB,EAAWC,GACjC,IAAM2C,EAAUvB,YAAQ3B,GAAM,SAAA4B,GAC5BA,EAAUtB,GAAGC,GAAKP,EAAKM,GAAGC,GAAK,EAAI,KAErCQ,EAAQmC,GAwCeC,CAAe7C,EAAGC,eE/H7C6C,IAASC,OAAO,kBAAC,EAAD,MAASC,SAASC,eAAe,U","file":"static/js/main.f55b7e80.chunk.js","sourcesContent":["import React, { useState, useCallback, useRef } from 'react'\nimport { numRows, numCols } from './constants'\nimport produce from 'immer'\n\nconst gridStyles = {\n  display: 'grid',\n  gridTemplateColumns: `repeat(${numCols}, 20px)`\n}\n\n// 得到除自己本身之外(0, 0), 其余 8 个 cell 的坐标\nconst operations = [\n  [0, 1],\n  [0, -1],\n  [1, -1],\n  [-1, 1],\n  [1, 1],\n  [-1, -1],\n  [1, 0],\n  [-1, 0]\n]\n\nconst countNeighbours = (grid: number[][], x: number, y: number): number => {\n  // grid 代表坐标系统, x, y 分别代表其中的坐标\n  return operations.reduce((acc, coord) => {\n    const [i, j] = coord\n    const row = (x + i + numRows) % numRows\n    const col = (y + j + numCols) % numCols\n    acc += grid[row][col]\n    return acc\n  }, 0)\n}\n\nconst App: React.FC = () => {\n  const [grid, setGrid] = useState(() => {\n    return [...Array(numRows)].map(row => new Array(numCols).fill(0))\n  })\n  const [speed, setSpeed] = useState(100)\n  const [running, setRunning] = useState(false)\n  // 使用 ref 保存最新的 running state\n  const runningRef = useRef(running)\n  runningRef.current = running\n  const speedRef = useRef(speed)\n  speedRef.current = speed\n\n  const runSimulation = useCallback(() => {\n    // 由于不想在每次 render 时候重新改变调用这一函数, 因此使用\n    // useCallback 进行包装, 并且依赖数组为空表示该函数不管这个组件 \n    // render 多少次, 永远只执行一次\n    // 但是这个函数本身是一个递归\n    if (!runningRef.current) {\n      // 同时注意, 由于该函数只执行一次, 里面的 running 对应的是第一次执行的 running, 尽管后面 running 改变\n      // 但由于闭包性质, 函数里面获取的 running 并不会发生改变, 因此需要使用 ref 追踪最新的 running state\n      // 这样获取的 runningRef 永远都是最新的\n      return\n    }\n\n    // 设置新 grid\n    setGrid(prevGrid => {\n      return produce(prevGrid, draftGrid => {\n        for (let x = 0; x < numRows; x++) {\n          for (let y = 0; y < numCols; y++) {\n            const neighbours = countNeighbours(prevGrid, x, y)\n\n            if (neighbours < 2 || neighbours > 3) {\n              draftGrid[x][y] = 0\n            } else if (prevGrid[x][y] === 0 && neighbours === 3) {\n              draftGrid[x][y] = 1\n            }\n          }\n        }    \n      })\n    })\n    // 递归不断调用\n    setTimeout(runSimulation, speedRef.current)\n  }, [])\n\n  const handleClearGrid = () => {\n    setGrid([...Array(numRows)].map(row => new Array(numCols).fill(0)))\n  }\n\n  const handleRandomGrid = () => {\n    const rows = []\n    for (let i = 0; i < numRows; i++) {\n      rows.push(Array.from(Array(numCols), () => Math.random() > 0.5 ? 1 : 0))\n    }\n    setGrid(rows)\n  }\n\n  const handleColClick = (i: number, j: number): void => {\n    const newGrid = produce(grid, draftGrid => {\n      draftGrid[i][j] = grid[i][j] ? 0 : 1\n    })\n    setGrid(newGrid)\n  }\n\n  const handleRunning = () => {\n    setRunning(!running)\n    if (!running) {\n      runningRef.current = true\n      runSimulation()  \n    }\n  }\n\n  const handleRunningSpeed = (e: React.ChangeEvent<HTMLInputElement>) => {\n    setSpeed(Number(e.target.value))\n  }\n\n  return (\n    <>\n      <div>\n        <button onClick={handleRunning}>\n          {running ? 'stop' : 'start'}\n        </button>\n        <button onClick={handleClearGrid}>clear</button>\n        <button onClick={handleRandomGrid}>random</button>\n      </div>\n      <div>\n        <span>Speed(50~2000):</span>\n        <input \n          type=\"range\"\n          min=\"50\"\n          max=\"2000\"\n          value={speed}\n          onChange={handleRunningSpeed}\n        />\n      </div>\n      <div style={gridStyles}>\n        {grid.map((row, i) => row.map((col, j) => (\n          <div \n            key={`${i}-${j}`}\n            className=\"col\" \n            style={{backgroundColor: grid[i][j] ? 'blue' : undefined}}\n            onClick={() => handleColClick(i, j)}\n          />\n        )))}\n      </div>\n    </>\n  )\n}\n\nexport default App\n","export const numRows = 50\nexport const numCols = 50","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}